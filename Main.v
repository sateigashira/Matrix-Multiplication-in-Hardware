`timescale 1ns/10ps
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module lab6(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================




//=======================================================
//  Structural coding
//=======================================================



endmodule

module maca(
	input signed [7:0] a_data,
	input signed [7:0] b_data,
	input clk, mac_clr,
	output reg signed [18:0] adder
);
	//reg [18:0] S;
	wire signed [18:0] mult;
	
	assign mult = a_data * b_data;
	
	always @ (posedge clk)
	begin
		if (mac_clr)
			adder <= mult;
		else
			adder <= adder + mult;
	end
endmodule

module macb(
	input signed [7:0] a_data,
	input signed [7:0] b_data,
	input clk, mac_clr,
	output reg signed [18:0] adder
);
	//reg [18:0] S;
	wire signed [18:0] mult;
	
	assign mult = a_data * b_data;
	
	always @ (posedge clk)
	begin
		if (mac_clr)
			adder <= mult;
		else
			adder <= adder + mult;
	end
endmodule

module macc(
	input signed [7:0] a_data,
	input signed [7:0] b_data,
	input clk, mac_clr,
	output reg signed [18:0] adder
);
	//reg [18:0] S;
	wire signed [18:0] mult;
	
	assign mult = a_data * b_data;
	
	always @ (posedge clk)
	begin
		if (mac_clr)
			adder <= mult;
		else
			adder <= adder + mult;
	end
endmodule

module macd(
	input signed [7:0] a_data,
	input signed [7:0] b_data,
	input clk, mac_clr,
	output reg signed [18:0] adder
);
	//reg [18:0] S;
	wire signed [18:0] mult;
	
	assign mult = a_data * b_data;
	
	always @ (posedge clk)
	begin
		if (mac_clr)
			adder <= mult;
		else
			adder <= adder + mult;
	end
endmodule

module mace(
	input signed [7:0] a_data,
	input signed [7:0] b_data,
	input clk, mac_clr,
	output reg signed [18:0] adder
);
	//reg [18:0] S;
	wire signed [18:0] mult;
	
	assign mult = a_data * b_data;
	
	always @ (posedge clk)
	begin
		if (mac_clr)
			adder <= mult;
		else
			adder <= adder + mult;
	end
endmodule

module macf(
	input signed [7:0] a_data,
	input signed [7:0] b_data,
	input clk, mac_clr,
	output reg signed [18:0] adder
);
	//reg [18:0] S;
	wire signed [18:0] mult;
	
	assign mult = a_data * b_data;
	
	always @ (posedge clk)
	begin
		if (mac_clr)
			adder <= mult;
		else
			adder <= adder + mult;
	end
endmodule

module macg(
	input signed [7:0] a_data,
	input signed [7:0] b_data,
	input clk, mac_clr,
	output reg signed [18:0] adder
);
	//reg [18:0] S;
	wire signed [18:0] mult;
	
	assign mult = a_data * b_data;
	
	always @ (posedge clk)
	begin
		if (mac_clr)
			adder <= mult;
		else
			adder <= adder + mult;
	end
endmodule

module mach(
	input signed [7:0] a_data,
	input signed [7:0] b_data,
	input clk, mac_clr,
	output reg signed [18:0] adder
);
	//reg [18:0] S;
	wire signed [18:0] mult;
	
	assign mult = a_data * b_data;
	
	always @ (posedge clk)
	begin
		if (mac_clr)
			adder <= mult;
		else
			adder <= adder + mult;
	end
endmodule

module RAM (
     input [18:0] data_in,
     input [63:0] addr,
     input write_enable, clk,
     output reg [18:0] out
);

// initialize RAM
(* ramstyle = "M9K" *) reg signed [18:0] mem[63:0];

// load new data to RAM if clock is toggled
always @(posedge clk) begin
     // only write new data if the ram selected and write is enabled
     if (write_enable)
          mem[addr] = data_in;
end 

endmodule

module matrix_mult_8x8( 
     input clk,
     input start,
     input reset,
     output reg done,
     output reg [10:0] clock_count
);
// states for the state machine
localparam S0 = 2'd0;
localparam S1 = 2'd1;
localparam S2 = 2'd2;
reg [1:0] state;
reg [1:0] nextstate;

// multiplication helper variables
reg signed [18:0] product;
wire signed [18:0] mem;
reg [3:0] matrix_A_col;
reg [3:0] matrix_B_col;
reg [3:0] matrix_A_row;
reg [3:0] matrix_B_row;
reg [3:0] matrix_C_col;
reg [3:0] matrix_C_row;
reg [3:0] matrix_A2_col;
reg [3:0] matrix_B2_col;
reg [3:0] matrix_A2_row;
reg [3:0] matrix_B2_row;
reg [3:0] matrix_C2_row;
reg [3:0] matrix_C3_col;
reg [3:0] matrix_C2_col;

reg [3:0] matrix_A3_col;
reg [3:0] matrix_B3_col;
reg [3:0] matrix_A3_row;
reg [3:0] matrix_B3_row;
reg [3:0] matrix_C3_row;
reg [3:0] matrix_C4_row;
reg [3:0] matrix_C4_col;

reg [3:0] matrix_A4_col;
reg [3:0] matrix_B4_col;
reg [3:0] matrix_A4_row;
reg [3:0] matrix_B4_row;

reg [63:0] matrix_A_addr;
reg [63:0] matrix_A_addr2;
reg [63:0] matrix_B_addr;
reg [63:0] matrix_B_addr2;

reg [63:0] matrix_A_addr3;
reg [63:0] matrix_A_addr4;
reg [63:0] matrix_B_addr3;
reg [63:0] matrix_B_addr4;

reg signed [7:0] val_A;
reg signed [7:0] val_A2;
reg signed [7:0] val_B;
reg signed [7:0] val_B2;

reg signed [7:0] val_A3;
reg signed [7:0] val_A4;
reg signed [7:0] val_B3;
reg signed [7:0] val_B4;

reg writing;
reg clr;
reg write;
reg [3:0] doneflag = 0;
reg [63:0] address;
reg [3:0] n;
wire signed [18:0] product1;
wire signed [18:0] product2;
wire signed [18:0] product3;
wire signed [18:0] product4;

reg signed [18:0] buffer [7:0];
integer number = 0;
integer number2 = 8;
integer number3 = 1;
integer number4 = 9;
integer counter = 0;
integer w = 0;
reg rite = 0;
//random variable to always pass 1 to the write enable of the output RAM
reg rando = 1;
// RAM variables
(* ramstyle = "M9K" *) reg signed [7:0] RAM_A[63:0];
(* ramstyle = "M9K" *) reg signed [7:0] RAM_B[63:0];



// instantiate MAC
maca mac1 (val_A, val_B, clk, clr, product1);
macd mac2 (val_A2, val_B, clk, clr, product2);
macc mac3 (val_A, val_B2, clk, clr, product3);
macb mac4 (val_A2, val_B2, clk, clr, product4);

mace mac5 (val_A3, val_B, clk, clr, product5);
mach mac6 (val_A4, val_B2, clk, clr, product6);
macg mac7 (val_A3, val_B2, clk, clr, product7);
macf mac8 (val_A4, val_B, clk, clr, product8);

//code for the buffer. Waits until it finished calculations for each row/col before assigning the correct product
//to the buffer. Then alternates and writes those values to product each clock cycle for a total of 4 writes per cycle
always @(posedge clk) begin
if (counter == 9) begin
	buffer[0] = product1;
	buffer[1] = product3;
	buffer[2] = product2;
	buffer[3] = product4;
	
	buffer[4] = product5;
	buffer[5] = product6;
	buffer[6] = product7;
	buffer[7] = product8;
	counter = 0;
	rite = 1;
	end
end
always @(posedge clk) begin
if(rite)begin
	product = buffer[w];
	
	#1
	w = w+1;
	if(w == 1 || w == 3)begin
		address = number;
		number = number + 1;
		if(number == 8)
			number = 16;
		if(number == 24)
			number = 32;
		if(number == 40)
			number = 48;
		end
	if(w == 2 || w == 4)begin
		address = number2;
		number2 = number + 8;
		end
	if (w == 5 || w == 7)
		address = number3;
		number3 = number + 1;
	if (w == 6 || w == 8)
		address = number4;
		number4 = number2 + 8;
	if (address == 63)
		doneflag = 1;
	if(w > 7)begin
		w=0;
		rite = 0;
		end
	end
end

// instantiate output RAM 
RAM RAMOUTPUT(product,address,rando,clk,mem);

// populate the RAM with the .txt contents
initial begin
     $readmemb("/Users/remmi/Documents/EEC 180/Lab6t3/ram_a_init.txt",RAM_A);
     $readmemb("/Users/remmi/Documents/EEC 180/Lab6t3/ram_b_init.txt",RAM_B);
end

// clock input handler
always @(posedge clk or posedge reset) begin
	case (state)
		S0: begin
			if (reset) begin
				clock_count <= 11'd0;
				done <= 0;
				state <= S0;
				clr <= 1;
			end

			if (start && ~reset) begin
				nextstate = S1;
				n = 4'd1;
				matrix_C_col = 4'd1;
				matrix_C_row = 4'd1;
				matrix_C2_col = 4'd1;
				matrix_C2_row = 4'd2;
				matrix_C3_col = 4'd2;
				
				matrix_C3_row = 4'd3;
				matrix_C4_row = 4'd4;
				val_A2 = 8'd0;
				val_A = 8'd0;
				val_B = 8'd0;
				val_B2 = 8'd0;
				val_A3 = 8'd0;
				val_A4 = 8'd0;
				val_B3 = 8'd0;
				val_B4 = 8'd0;
				clr = 1;
				writing = 0;
			end
		end
		S1: begin
			// increment the clock by 1
			clock_count = clock_count + 11'd1;
			// logic for iterating through matrix
			// check the status of a single multiplication
			if (writing) begin
				write = 1;
				clr = 1;
				//rite = 1;
				writing = 0;
			end else begin 
				write = 0;
				clr = 0;
				if (doneflag == 4'd1)
					done = 1;
			end
			counter = counter + 4'd1;
			if (n < 4'd9) begin
				matrix_B_col = matrix_C_col;
				matrix_A_row = matrix_C_row;
				matrix_B_row = n;
				matrix_A_col = n;
				
				matrix_B2_col = matrix_C3_col;
				matrix_A2_row = matrix_C2_row;
				matrix_A2_col = n;
				matrix_B2_row = n;
				
				matrix_B3_col = matrix_C2_col;
				matrix_A3_row = matrix_C3_row;
				matrix_A3_col = n;
				matrix_B3_row = n;
				
				matrix_B4_col = matrix_C4_col;
				matrix_A4_row = matrix_C4_row;
				matrix_A4_col = n;
				matrix_B4_row = n;
				
				//Calculate 2 separate addr values for Matrix A and Matrix B
				matrix_A_addr = ((matrix_A_col-4'd1)*4'd8)+(matrix_A_row - 4'd1);
				matrix_A_addr2 = ((matrix_A2_col-4'd1)*4'd8)+(matrix_A2_row - 4'd1);
				matrix_B_addr = ((matrix_B_col-4'd1)*4'd8)+(matrix_B_row - 4'd1);
				matrix_B_addr2 = ((matrix_B2_col-4'd1)*4'd8)+(matrix_B2_row - 4'd1);
				
				matrix_A_addr3 = ((matrix_A3_col-4'd1)*4'd8)+(matrix_A3_row - 4'd1);
				matrix_A_addr4 = ((matrix_A4_col-4'd1)*4'd8)+(matrix_A4_row - 4'd1);
				matrix_B_addr3 = ((matrix_B3_col-4'd1)*4'd8)+(matrix_B3_row - 4'd1);
				matrix_B_addr4 = ((matrix_B4_col-4'd1)*4'd8)+(matrix_B4_row - 4'd1);
				
				val_A = RAM_A[matrix_A_addr];
				val_A2 = RAM_A[matrix_A_addr2];
				val_B = RAM_B[matrix_B_addr];
				val_B2 = RAM_B[matrix_B_addr2];
				
				val_A3 = RAM_A[matrix_A_addr3];
				val_A4 = RAM_A[matrix_A_addr4];
				//val_B3 = RAM_B[matrix_B_addr3];
				//val_B4 = RAM_B[matrix_B_addr4];
				n = n + 4'd1;
				
			end else begin
			       	writing = 1;
				n = 4'd1;
			
				// C needs to be iterated
				if (matrix_C_row < 4'd7) begin
					matrix_C_row = matrix_C_row + 4'd2;
					matrix_C2_row = matrix_C_row + 4'd1;
					matrix_C3_row = matrix_C2_row + 4'd1;
					matrix_C4_row = matrix_C3_row + 4'd1;
					end
				else begin
					 if (matrix_C_col < 4'd8)begin
						matrix_C_col = matrix_C_col + 4'd2;
						matrix_C3_col = matrix_C_col + 4'd1;
						matrix_C2_col = matrix_C4_col - 4'd1;
						matrix_C4_col = matrix_C3_col + 4'd1;
						matrix_C_row = 4'd1;
						matrix_C2_row = 4'd2;						
					end else begin
						writing = 1;
					end
				end
			end
		end
		
		S2: begin
	 		done = 1;	
		end
	 	
		default: begin
			nextstate = S0;
		end	
	endcase
	state = nextstate;
end

endmodule
